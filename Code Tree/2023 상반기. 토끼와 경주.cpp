//https://www.codetree.ai/training-field/frequent-problems/problems/rabit-and-race/description?page=1&pageSize=20
#include<iostream>
#include<queue>

using namespace std;

//P마리 토끼 (시작점: (1,1)) -> NxM 행렬 1,1부터
//토끼의 정보
//1. 고유 번호 pid
//2. 필수 이동거리 d


//경주 진행 우선순위 순서
//1. 현재까지 점프 횟수 적은 토끼
//2. 현재 서있는 칸 (행+열) 작은 토끼
//3. 행 번호 작은 토끼
//4. 열 번호 작은 토끼
//5. 고유번호 작은 토끼

//점프
//i번 토끼의 d만큼 상하좌우
//칸 벗어나면 방향을 반대로 바꿈 -> 현재 바라보는 dir 저장해놔야함
//4개의 위치 우선순위
//1. 행+열 큰 칸
//2. 행 큰 칸
//3. 열 큰 칸

//점프했을 때 i번 토끼 제외 나머지 +=(행+열) 점수 얻음


//K번 턴 끝났을 때  (K번의 턴동안 한번이라도 뽑힌 토끼에 대해서만)
//  -> 참여했는지 배열 만들기(participated)
//점수 S 더하는 우선순위 
//1. 현재 서있는 칸 (행+열) 큰 토끼
//2. 행 번호 큰 토끼
//3. 열 번호 큰 토끼
//5. 고유번호 큰 토끼


// 이동거리 변경
// 특정 고유번호 t에 대해 이동거리 L배 하기 (10억 안넘으니까 ㄱㅊ)


// 얻은 점수 중 가장 높은 점수 출력 (경주마다 초기화 안됨)





int main() {

	

	return 0;
}

//토끼고유번호가 너무 크므로 구조체에 고유번호 넣고 그냥 배열[2000]로 해야할듯
//뛸때마다 우선순위 체크해야함